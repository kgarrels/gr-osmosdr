/* -*- c++ -*- */
/*
 * Copyright 2013 Dimitri Stolnikov <horiz0n@gmx.net>
 *
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for feature_t, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <string.h>
#include <stdlib.h>

#include <fcntl.h>
#include <unistd.h>
#include <termios.h>
#include <sys/stat.h>
#include <dirent.h>
#include <libgen.h> /* basename */

#include <ftdi.h>

#include <algorithm>
#include <iostream>
#include <fstream>
#include <string>
#include <cerrno>

#include <boost/assign.hpp>
#include <boost/format.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>

#include <gnuradio/io_signature.h>

#include "arg_helpers.h"
#include "sdr_14_source_c.h"

using namespace boost::assign;

#define DEFAULT_HOST  "127.0.0.1" /* We assume a running "siqs" from CuteSDR project */
#define DEFAULT_PORT  50000

/*
 * Create a new instance of rfspace_source_c and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
sdr_14_source_c_sptr make_sdr_14_source_c (const std::string &args)
{
  return gnuradio::get_initial_sptr(new sdr_14_source_c (args));
}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr_block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 0 input and 1 output.
 */
static const int MIN_IN = 0;	// mininum number of input streams
static const int MAX_IN = 0;	// maximum number of input streams
static const int MIN_OUT = 1;	// minimum number of output streams
static const int MAX_OUT = 1;	// maximum number of output streams

/*
 * The private constructor
 */
sdr_14_source_c::sdr_14_source_c (const std::string &args)
  : gr::sync_block ("sdr_14_source_c",
                    gr::io_signature::make (MIN_IN, MAX_IN, sizeof (gr_complex)),
                    gr::io_signature::make (MIN_OUT, MAX_OUT, sizeof (gr_complex))),
    _radio(RADIO_UNKNOWN),
    _tcp(-1),
    _udp(-1),
    _usb(-1),
    _running(false),
    _keep_running(false),
    _sequence(0),
    _nchan(1),
    _sample_rate(NAN),
    _bandwidth(0.0f),
    _fifo(NULL)
{
  std::string host = "";
  unsigned short port = 0;

  dict_t dict = params_to_dict(args);

  if ( dict.count("sdr-14") )
    dict["rfspace"] = dict["sdr-14"];

  std::string label = "sdr-14";

  if ( label.length() )
    std::cerr << "Wants to use " + label << " ";

  struct ftdi_context *ftdi;

  std::cerr << "in constructor for ftdi\n";

  if ((ftdi = ftdi_new()) == 0)
  {
      printf("ftdi_new failed\n");
      return;
  }

  int ret;
  if ((ret = ftdi_usb_open(ftdi, 0x0403, 0xf728)) < 0)    // sdr_14
  {
      printf("unable to open ftdi device: %d (%s)\n", ret, ftdi_get_error_string(ftdi));
      ftdi_free(ftdi);
      return;
  }
  _radio = RFSPACE_SDR_14; /* legitimate assumption, we only discovered SD-14 devices */
  _ftdi = ftdi;
  ftdi_usb_purge_buffers(_ftdi);

  _run_usb_read_task = true;
  _fifo = new boost::circular_buffer<gr_complex>( 200000 );
  if ( ! _fifo )
    throw std::runtime_error( "Failed to allocate sample FIFO" );

  _thread = gr::thread::thread( boost::bind(&sdr_14_source_c::usb_read_task, this) );

  /* Wait 10 ms before sending queries to device (required for networked radios). */
  boost::this_thread::sleep_for(boost::chrono::milliseconds(10));

  /* request & print device information */

  std::vector< unsigned char > response;

  // if ( ! label.length() ) /* label is empty, request name & serial from device */
  std::cerr << "Using ";

  unsigned char name[] = { 0x04, 0x20, 0x01, 0x00 };      /* NETSDR 4.1.1 Target Name */
  if ( transaction( name, sizeof(name), response ) )
  {
    char *product_id = (char *)&response[sizeof(name)];
    std::cerr << "RFSPACE " << " " << product_id << " ";
    //if (strcmp(product_id, "SDR-14") == 0) _radio = RFSPACE_SDR_14;    // detect sdr-14 by its name
  }

  unsigned char sern[] = { 0x04, 0x20, 0x02, 0x00 }; /* NETSDR 4.1.2 Target Serial Number */
  if ( transaction( sern, sizeof(sern), response ) )
    std::cerr << "SN " << &response[sizeof(sern)] << " ";

  /* NETSDR 4.1.4 Hardware/Firmware Versions */

  unsigned char bootver[] = { 0x05, 0x20, 0x04, 0x00, 0x00 };
  if ( transaction( bootver, sizeof(bootver), response ) )
    std::cerr << "BOOT " << *((uint16_t *)&response[sizeof(bootver)]) << " ";

  unsigned char firmver[] = { 0x05, 0x20, 0x04, 0x00, 0x01 };
  if ( transaction( firmver, sizeof(firmver), response ) )
    std::cerr << "FW " << *((uint16_t *)&response[sizeof(firmver)]) << " ";

  std::cerr << std::endl;

  /* preset reasonable defaults */

  set_sample_rate( 158730 );
  
#if 1
  std::cerr << "sample_rates: " << get_sample_rates().to_pp_string() << std::endl;
  std::cerr << "sample rate: " << (uint32_t)get_sample_rate() << std::endl;

  std::cerr << "freq range:  " << get_freq_range().to_pp_string() << std::endl;
  std::cerr << "center freq: " << (uint32_t)get_center_freq() << std::endl;

  std::cerr << "gain range:  " << get_gain_range().to_pp_string() << std::endl;
  std::cerr << "gain:        " << (uint32_t)get_gain() << std::endl;

  std::cerr << "bw range:    " << get_bandwidth_range().to_pp_string() << std::endl;
#endif
}

/*
 * Our virtual destructor.
 */
sdr_14_source_c::~sdr_14_source_c ()
{

  _run_usb_read_task = false;
  _thread.join();

  ftdi_free(_ftdi);

  if ( _fifo )
  {
    delete _fifo;
    _fifo = NULL;
  }
}

void sdr_14_source_c::apply_channel( unsigned char *cmd, size_t chan )
{
}

bool sdr_14_source_c::setDsp()
{
  int row;
  std::vector< unsigned char > response;

  for (row=0; row < (int)BWKHZ_150.size(); row++)
  {
    if ( ! transaction((unsigned char *)&BWKHZ_150[row][0], BWKHZ_150[row].size(), response)) 
    {
      std::cerr << "setDsp() failed.\n";
      return false;
    }
  }
  std::cerr << "setDsp() done.\n";
  return true;
}

bool sdr_14_source_c::transaction( const unsigned char *cmd, size_t size )
{
  std::vector< unsigned char > response;

  if ( ! transaction( cmd, size, response ) )
    return false;

  /* comparing the contents is not really feasible due to protocol */
  if ( response.size() == size ) /* check response size against request */
    return true;

  return false;
}


bool sdr_14_source_c::transaction( const unsigned char *cmd, size_t size, 
                                   std::vector< unsigned char > &response )
{
  size_t rx_bytes = 0;
  unsigned char data[1024*10];
  int ret=0;

  response.clear();

//#define VERBOSE
#ifdef VERBOSE
  printf("< ");
  for (size_t i = 0; i < size; i++)
    printf("%02x ", (unsigned char) cmd[i]);
  printf("\n");
#endif

  if ( ret = ftdi_write_data(_ftdi, cmd, size)  )
  {
    //std::cerr << "written " << ret << "\n";
    if (ret != (int)size) return false;
  }

  std::unique_lock<std::mutex> lock(_resp_lock);
  _resp_avail.wait(lock);

  rx_bytes = _resp.size();
  memcpy( data, _resp.data(), rx_bytes );

  response.resize( rx_bytes );
  memcpy( response.data(), data, rx_bytes );

#ifdef VERBOSE
  printf("> ");
  for (size_t i = 0; i < rx_bytes; i++)
    printf("%02x ", (unsigned char) data[i]);
  printf("\n");
#endif

  return true;
}

size_t sdr_14_source_c::read_bytes( char *data, size_t size, bool &run )
{
  size_t nbytes = 0;
  
  while ( nbytes < size && run )
  {
    int nread=0; 

    nread = ftdi_read_data( _ftdi, (unsigned char *)&data[nbytes], 1);                // SDR-14
    if (nread < 0 ) std::cerr << " nread " << nread <<  " " <<_ftdi->error_str <<"\n";

    if ( nread == 0 )
      continue;   

    if ( nread < 0 )
      break;

    nbytes++;
  }
  return nbytes;
}

void sdr_14_source_c::usb_read_task()
{
  uint cnt = 0;
  char data[1024*10];
  size_t n_avail, to_copy;

  // if ( -1 == _usb ) return;
  while ( _run_usb_read_task )
  {
    size_t nbytes;
    nbytes = read_bytes( data, 2, _run_usb_read_task );
    if ( nbytes != 2 )
      continue;

    size_t length = ((data[1] << 8) | data[0]) & 0x1fff;
    if ( 0 == length ) /* SDR-IQ 5.4.1 Output Data Item 0 */
      length = 1024*8 + 2;

    if ( length <= 2 )
      continue;

    length -= 2; /* subtract header */

    if ( length > sizeof(data) - 2 )
    {
      _run_usb_read_task = false;
      continue;
    }

    nbytes = read_bytes( data + 2, length, _run_usb_read_task );
    if ( nbytes != length )
      continue;

    if ( 1024*8 == length )
    {
      // SDR-14 needs ack
      if(cnt++ > 10) 
      {
        ack();
        cnt = 0;
      }
    
      /* push samples into the fifo */
      _fifo_lock.lock();

      size_t num_samples = length / 4;
      n_avail = _fifo->capacity() - _fifo->size();
      to_copy = (n_avail < num_samples ? n_avail : num_samples);

      #define SCALE_16  (1.0f/32768.0f)

      int16_t *sample = (int16_t *)(data + 2);

      for ( size_t i = 0; i < to_copy; i++ )
      {
        /* Push sample to the fifo */
       _fifo->push_back( gr_complex( *(sample+0) * SCALE_16,
                                      *(sample+1) * SCALE_16 ) );
        /* offset to the next I+Q sample */
        sample += 2;
      }

      #undef SCALE_16

      _fifo_lock.unlock();

      /* We have made some new samples available to the consumer in work() */
      if (to_copy) {
        //std::cerr << "+" << std::flush;
        _samp_avail.notify_one();
      }

      /* Indicate overrun, if neccesary */
      if (to_copy < num_samples)
        std::cerr << "O" << std::flush;
    }
    else
    {
      /* copy response & signal transaction */
      _resp_lock.lock();
      _resp.clear();
      _resp.resize( length + 2 );
      memcpy( _resp.data(), data, length + 2 );
      _resp_lock.unlock();
      _resp_avail.notify_one();
    }
  }
}



bool sdr_14_source_c::ack()
{
  //std::cerr << ".";
  unsigned char ack[] = { 0x03, 0x60, 0x00 };
  ftdi_write_data(_ftdi, ack, 3);
}

bool sdr_14_source_c::start()
{
  _sequence = 0;
  _running = true;
  _keep_running = false;

  /* SDR-IP 4.2.1 Receiver State */
  /* NETSDR 4.2.1 Receiver State */
  unsigned char start[] = { 0x08, 0x00, 0x18, 0x00, 0x81, 0x02, 0x00, 0x01 };

  // set if gain
  std::cerr << "start, set if gain\n";
  unsigned char ifgain[] = { 0x06, 0x00, 0x40, 0x00, 0x00, 0x18 }; 
  transaction( ifgain, sizeof(ifgain) );

  std::cerr << "start, start cmd\n";
  return transaction( start, sizeof(start) );
}

bool sdr_14_source_c::stop()
{
  std::cerr << "stopping. \n";

  if ( ! _keep_running )
    _running = false;
  _keep_running = false;

  if ( _fifo )
    _fifo->clear();

  /* SDR-IP 4.2.1 Receiver State */
  /* NETSDR 4.2.1 Receiver State */
  unsigned char stop[] = { 0x08, 0x00, 0x18, 0x00, 0x00, 0x01, 0x00, 0x01 };
  return transaction( stop, sizeof(stop) );
}

/* Main work function, pull samples from the socket */
int sdr_14_source_c::work( int noutput_items,
                           gr_vector_const_void_star &input_items,
                           gr_vector_void_star &output_items )
{
  unsigned char data[1024*10];

  if ( ! _running )
    return WORK_DONE;

  if ( noutput_items > 0 )
  {
    gr_complex *out = (gr_complex *)output_items[0];

    std::unique_lock<std::mutex> lock(_fifo_lock);

    /* Wait until we have the requested number of samples */
    int n_samples_avail = _fifo->size();

    while ( n_samples_avail < noutput_items )
    {
      _samp_avail.wait(lock);
      n_samples_avail = _fifo->size();
    }

    for ( int i = 0; i < noutput_items; ++i )
    {
      out[i] = _fifo->at(0);
      _fifo->pop_front();
    }
  }

  return noutput_items;
}


typedef struct
{
  std::string name;
  std::string sn;
  std::string addr;
  uint16_t port;
} unit_t;


static std::vector < unit_t > discover_sdr_14()
{
  std::vector < unit_t > units;
  struct ftdi_context *ftdi;

  std::cerr << "in discover_sdr_14 ftdi\n";

  int ret;
  struct ftdi_version_info version;
  if ((ftdi = ftdi_new()) == 0)
  {
      std::cerr << "ftdi_new failed\n";
      return units;
  }

  version = ftdi_get_library_version();
  std::cerr << "Initialized libftdi " << version.version_str << "\n";

  if ((ret = ftdi_usb_open(ftdi, 0x0403, 0xf728)) < 0)
  {
      printf("unable to open ftdi device: %d (%s)\n", ret, ftdi_get_error_string(ftdi));
      ftdi_free(ftdi);
      return units;
  }

  unsigned int chipid;
  printf("ftdi_read_chipid: %d\n", ftdi_read_chipid(ftdi, &chipid));
  printf("FTDI chipid: %X\n", chipid);

  // was only discover, close 
  if ((ret = ftdi_usb_close(ftdi)) < 0)
  {
      printf("unable to close ftdi device: %d (%s)\n", ret, ftdi_get_error_string(ftdi));
      ftdi_free(ftdi);
      return units;
  }
  ftdi_free(ftdi);

  unit_t unit;
  unit.name = "SDR-14";
  unit.sn = "?";
  unit.addr = "ftdi";
  unit.port = 0;
  units.push_back( unit );

  return units;
}


std::vector<std::string> sdr_14_source_c::get_devices( bool fake )
{
  std::vector<std::string> devices;
  std::vector < unit_t > units;

  units = discover_sdr_14();
  
  for (unit_t u : units)
  {
    std::cerr << u.name << " " << u.sn << " " << u.addr <<  ":" << u.port
              << std::endl;

    std::string type = u.name;
    std::transform(type.begin(), type.end(), type.begin(), ::tolower);

    devices += str(boost::format("%s=%s,label='RFSPACE %s SN %s'")
                   % type % u.addr % u.name % u.sn);
  }

  if ( devices.empty() && fake )
  {
    devices += str(boost::format("sdr-14=%s,label='RFSPACE SDR-14 Receiver'")
                   % "");
  }

  return devices;
}

size_t sdr_14_source_c::get_num_channels()
{
  return _nchan;
}


osmosdr::meta_range_t sdr_14_source_c::get_sample_rates()
{
  osmosdr::meta_range_t range;

  range += osmosdr::range_t( 158730 );
  return range;
}

double sdr_14_source_c::set_sample_rate( double rate )
{
    double closest_rate = get_sample_rates().clip( rate, true );

    if ( closest_rate != rate )
      std::cerr << "Picked closest supported sample rate of " << (uint32_t)closest_rate << " Hz"
                << std::endl;

    rate = closest_rate; /* override */

  if ( _running )
  {
    _keep_running = true;
    stop();
  }

  //sdr-14 needs to load AD6620
  if ( !setDsp())
    throw std::runtime_error("setDsp() failed");
  _sample_rate = rate;

  if ( _running )
  {
    start();
  }

  return get_sample_rate();
}

double sdr_14_source_c::get_sample_rate()
{
  return _sample_rate;
}

#define SDR_IQ_ADC_CLOCK 66666667 /* SDR-IQ 5.2.4 I/Q Data Output Sample Rate */
osmosdr::freq_range_t sdr_14_source_c::get_freq_range( size_t chan )
{
  osmosdr::freq_range_t range;

  /* does not support range query, use hardcoded values */
  range += osmosdr::range_t(0, SDR_IQ_ADC_CLOCK / 2.0f);
  return range;
}

double sdr_14_source_c::set_center_freq( double freq, size_t chan )
{
  uint32_t u32_freq = freq;

  /* SDR-IQ 5.2.2 Receiver Frequency */
  /* SDR-IP 4.2.2 Receiver Frequency */
  /* NETSDR 4.2.3 Receiver Frequency */
  unsigned char tune[] = { 0x0A, 0x00, 0x20, 0x00, 0x00, 0xb0, 0x19, 0x6d, 0x00, 0x01 };

  apply_channel( tune, chan );

  tune[sizeof(tune)-5] = u32_freq >>  0;
  tune[sizeof(tune)-4] = u32_freq >>  8;
  tune[sizeof(tune)-3] = u32_freq >> 16;
  tune[sizeof(tune)-2] = u32_freq >> 24;
  tune[sizeof(tune)-1] = 0;

  std::cerr << "set_centr_freq " << freq/1000 << "kHz\n";
  transaction( tune, sizeof(tune) );

  return get_center_freq( chan );
}

double sdr_14_source_c::get_center_freq( size_t chan )
{
  /* SDR-IQ 5.2.2 Receiver Frequency */
  /* SDR-IP 4.2.2 Receiver Frequency */
  /* NETSDR 4.2.3 Receiver Frequency */
  unsigned char freq[] = { 0x05, 0x20, 0x20, 0x00, 0x00 };

  apply_channel( freq, chan );

  std::vector< unsigned char > response;

  if ( ! transaction( freq, sizeof(freq), response ) )
    throw std::runtime_error("get_center_freq failed");

  uint32_t frequency = 0;
  frequency |= response[response.size()-5] <<  0;
  frequency |= response[response.size()-4] <<  8;
  frequency |= response[response.size()-3] << 16;
  frequency |= response[response.size()-2] << 24;

  return frequency;
}

double sdr_14_source_c::set_freq_corr( double ppm, size_t chan )
{
  return get_freq_corr( chan );
}

double sdr_14_source_c::get_freq_corr( size_t chan )
{
  return 0;
}

std::vector<std::string> sdr_14_source_c::get_gain_names( size_t chan )
{
  std::vector< std::string > names;

  names += "ATT";

  return names;
}

osmosdr::gain_range_t sdr_14_source_c::get_gain_range( size_t chan )
{
  return osmosdr::gain_range_t(-20, 10, 10);
}

osmosdr::gain_range_t sdr_14_source_c::get_gain_range( const std::string & name, size_t chan )
{
  return get_gain_range( chan );
}

bool sdr_14_source_c::set_gain_mode( bool automatic, size_t chan )
{
  return false;
}

bool sdr_14_source_c::get_gain_mode( size_t chan )
{
  return false;
}

double sdr_14_source_c::set_gain( double gain, size_t chan )
{
  /* SDR-IQ 5.2.5 RF Gain */
  /* SDR-IP 4.2.3 RF Gain */
  /* NETSDR 4.2.6 RF Gain */
  unsigned char atten[] = { 0x06, 0x00, 0x38, 0x00, 0x00, 0x00 };

  apply_channel( atten, chan );

  if ( gain <= -20 )
    atten[sizeof(atten)-1] = 0xE2;
  else if ( gain <= -10 )
    atten[sizeof(atten)-1] = 0xEC;
  else if ( gain <= 0 )
    atten[sizeof(atten)-1] = 0xF6;
  else /* +10 dB */
    atten[sizeof(atten)-1] = 0x00;
  transaction( atten, sizeof(atten) );

  // set if gain
  std::cerr << "set_gain " << gain << "\n";
  unsigned char ifgain[] = { 0x06, 0x00, 0x40, 0x00, 0x00, 0x18 };  // snd 06 00 40 00 00 18
  transaction( ifgain, sizeof(ifgain) );

  return get_gain( chan );
}

double sdr_14_source_c::set_gain( double gain, const std::string & name, size_t chan )
{
  return set_gain( gain, chan );
}

double sdr_14_source_c::get_gain( size_t chan )
{
  /* SDR-IQ 5.2.5 RF Gain */
  /* SDR-IP 4.2.3 RF Gain */
  /* NETSDR 4.2.6 RF Gain */
  unsigned char atten[] = { 0x05, 0x20, 0x38, 0x00, 0x00 };

  apply_channel( atten, chan );

  std::vector< unsigned char > response;

  if ( ! transaction( atten, sizeof(atten), response ) )
    throw std::runtime_error("get_gain failed");

  unsigned char code = response[response.size()-1];

  double gain = code;

  if( code & 0x80 )
    gain = (code & 0x7f) - 0x80;

  gain += 10;

  return gain;
}

double sdr_14_source_c::get_gain( const std::string & name, size_t chan )
{
  return get_gain( chan );
}

std::vector< std::string > sdr_14_source_c::get_antennas( size_t chan )
{
  std::vector< std::string > antennas;

  antennas += get_antenna( chan );

  return antennas;
}

std::string sdr_14_source_c::set_antenna( const std::string & antenna, size_t chan )
{
  return get_antenna( chan );
}

std::string sdr_14_source_c::get_antenna( size_t chan )
{
  /* We only have a single receive antenna here */
  return "RX";
}

#define BANDWIDTH 34e6

double sdr_14_source_c::set_bandwidth( double bandwidth, size_t chan )
{
  return BANDWIDTH;
}

double sdr_14_source_c::get_bandwidth( size_t chan )
{
  return _bandwidth;
}

osmosdr::freq_range_t sdr_14_source_c::get_bandwidth_range( size_t chan )
{
  osmosdr::freq_range_t bandwidths;

  bandwidths += osmosdr::range_t( BANDWIDTH );

  return bandwidths;
}
